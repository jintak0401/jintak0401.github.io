<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://jintak0401.github.io/</id><title>HashTable</title><subtitle>개발하면서 겪은 어려움과 깨달음을 공유하는 블로그입니다.</subtitle> <updated>2022-04-18T16:27:40+09:00</updated> <author> <name>Han Jintak</name> <uri>https://jintak0401.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://jintak0401.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="ko-KR" href="https://jintak0401.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 Han Jintak </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>[백준 4195] 친구 네트워크 (파이썬 / Python)</title><link href="https://jintak0401.github.io/posts/boj-4195/" rel="alternate" type="text/html" title="[백준 4195] 친구 네트워크 (파이썬 / Python)" /><published>2022-04-18T16:26:00+09:00</published> <updated>2022-04-18T16:26:00+09:00</updated> <id>https://jintak0401.github.io/posts/boj-4195/</id> <content src="https://jintak0401.github.io/posts/boj-4195/" /> <author> <name>HashTable</name> </author> <category term="알고리즘" /> <category term="백준" /> <summary> 📑 문제 문제링크 : 친구 네트워크 🤔 생각의 흐름 Disjoint Set 자료구조가 필요한 문제입니다. 귀찮은 부분은 이름이 숫자로 주어진 것이 아니라 문자열로 이루어진 점과 사람이 총 몇 명인지 모르는 점입니다. 문자열 이름은 딕셔너리를 이용해서 처리해주면 될 것 같네요. 처리해주는 방법은 디테일하게 2가지가 있습니다. 딕셔너리 key 값에 사람 이름을 담고, value 값으로 루트노드가 아니라면 부모의 이름을, 루트 노드라면 해당 tree 의 노드 갯수를 저장하는 방법 딕셔너리 key 값에 사람 이름을 담고 value 값으로 리스트의 인덱스 번호를 저장하여, 리스트를 이용해 disjoint set 을 구현하는 방법 설명은 1번 방법으로 설명... </summary> </entry> <entry><title>[백준 18809] Gaaaaaaaaaarden (파이썬 / Python)</title><link href="https://jintak0401.github.io/posts/boj-18809/" rel="alternate" type="text/html" title="[백준 18809] Gaaaaaaaaaarden (파이썬 / Python)" /><published>2022-04-17T12:33:00+09:00</published> <updated>2022-04-17T12:33:00+09:00</updated> <id>https://jintak0401.github.io/posts/boj-18809/</id> <content src="https://jintak0401.github.io/posts/boj-18809/" /> <author> <name>HashTable</name> </author> <category term="알고리즘" /> <category term="백준" /> <summary> 📑 문제 문제링크 : Gaaaaaaaaaarden 🤔 생각의 흐름 풀기 위해 아이디어적 어려움을 느낄만한 부분은 크게 없는 것 같습니다. 배양액을 뿌릴 수 있는 위치들 중에서 서로다른 R 개와 G 개를 뽑아 BFS 를 수행해야합니다. 다만 좀 귀찮은 부분은 빨간색과 초록색 배양액의 BFS 를 병렬적으로 수행해야하는 부분입니다. 처음에는 visited 리스트에 방문한 위치를 boolean 으로 기록하고 각 배양액이 동시에 도달한 위치를 set 을 이용한 큐로 풀었습니다만 풀이가 많이 느렸습니다. 다른 분의 코드를 참고하여 입력받은 정원에 기록하는 방법을 알게되었습니다. 빨간색 배양액이 퍼질 자리에 +(현재 BFS 단계)를 기록하고 초록색 배양액이 퍼질 자리에는 -(현재 BFS 단계)를 기록합... </summary> </entry> <entry><title>[백준 17435] 합성함수와 쿼리 (파이썬 / Python)</title><link href="https://jintak0401.github.io/posts/boj-17435/" rel="alternate" type="text/html" title="[백준 17435] 합성함수와 쿼리 (파이썬 / Python)" /><published>2022-04-16T15:30:00+09:00</published> <updated>2022-04-16T15:30:00+09:00</updated> <id>https://jintak0401.github.io/posts/boj-17435/</id> <content src="https://jintak0401.github.io/posts/boj-17435/" /> <author> <name>HashTable</name> </author> <category term="알고리즘" /> <category term="백준" /> <summary> 📑 문제 문제링크 : 합성함수와 쿼리 🤔 생각의 흐름 얼마 전에 알게된 희소 배열 알고리즘을 써야겠다고 생각했습니다. ‘희소 배열이 뭐지?’ 하시는 분들은 이 글을 보고 와주세요. 🎯 풀이방법 희소 배열 문제이며, 시간복잡도는 $O((m + Q) \log N)$ 입니다. move[i][j] : j 번 노드가 $2^i$ 번 이동했을 때의 위치 희소 배열 알고리즘을 위한 전처리를 해줍니다. 입력받은 쿼리를 전처리한 리스트를 이용하여 구합니다. 🔎 유의할 점 희소 배열 알고리즘을 이해하고 푼다면 크게 유의할 점은 없습니다. 💻 코드 from sys import stdin input = stdin.readline def... </summary> </entry> <entry><title>[알고리즘] 희소 배열(Sparse Table) 알고리즘</title><link href="https://jintak0401.github.io/posts/theory-sparse-array/" rel="alternate" type="text/html" title="[알고리즘] 희소 배열(Sparse Table) 알고리즘" /><published>2022-04-16T15:24:00+09:00</published> <updated>2022-04-16T16:00:00+09:00</updated> <id>https://jintak0401.github.io/posts/theory-sparse-array/</id> <content src="https://jintak0401.github.io/posts/theory-sparse-array/" /> <author> <name>HashTable</name> </author> <category term="알고리즘" /> <category term="이론" /> <summary> 🤔 희소 배열이 뭐야? 희소 배열의 정의는 배열 원소의 갯수가 배열의 길이보다 작은 배열이라고 합니다. 그런데 제가 설명할 알고리즘에서는 배열의 원소 갯수가 배열의 길이와 같은데 어째서 희소 배열인지는 잘 모르겠네요… 이 알고리즘은 노드당 out-degree(나가는 간선의 갯수)가 1인 단방향 그래프에서, i 번 노드로부터 N 번 이동했을 때 어떤 노드에 도달하는지 알아내는데 매우 유용합니다. 📃 희소 배열 알고리즘 그냥 구하면 안돼? N 개의 노드들에 대해 M 번 이동 후 위치를 묻는다고 해봅시다. 그냥 구하게된다면 이 때의 시간복잡도는 $O(N M)$일 것입니다. 만약 N 과 M 이 100,000이라면 N*M = 100억입니다. 그냥 구하기엔 너무 비효율적이죠. 알고리즘 설명 알고... </summary> </entry> <entry><title>[백준 2213] 트리의 독립집합 (파이썬 / Python)</title><link href="https://jintak0401.github.io/posts/boj-2213/" rel="alternate" type="text/html" title="[백준 2213] 트리의 독립집합 (파이썬 / Python)" /><published>2022-04-15T13:22:00+09:00</published> <updated>2022-04-15T13:23:25+09:00</updated> <id>https://jintak0401.github.io/posts/boj-2213/</id> <content src="https://jintak0401.github.io/posts/boj-2213/" /> <author> <name>HashTable</name> </author> <category term="알고리즘" /> <category term="백준" /> <summary> 📑 문제 문제링크 : 트리의 독립집합 🤔 생각의 흐름 처음에는 각 노드마다 선택했을 때와 선택하지 않았을 때, 두 경우의 해당 노드부터 leaf 노드까지의 가중치 합을 저장하는 dp 리스트에 저장하여 해결했습니다. 하지만 다른 분의 풀이를 보니 굳이 dp 리스트를 사용하지 않고, 노드에 방문할 때마다 선택했을 때와 선택하지 않았을 때를 함께 계산해 나가며 풀었습니다. 이 때의 로직과 코드가 더 간단했습니다. 🎯 풀이방법 트리 문제이며, 시간복잡도는 $O(N)$ 입니다. arr : 가중치 리스트. 1-based 로 저장하기 위해 맨 앞에 0을 추가했습니다. tree : 각 노드와 연결되어있는 다른 노드가 저장되는 2차원 리스트. 입력받으면서 어떤 노드가 부모노드인지 알 수 ... </summary> </entry> </feed>
