[ { "title": "[백준 4195] 친구 네트워크 (파이썬 / Python)", "url": "/posts/boj-4195/", "categories": "알고리즘, 백준", "tags": "알고리즘, 백준, Disjoint Set", "date": "2022-04-18 16:26:00 +0900", "snippet": "📑 문제문제링크 : 친구 네트워크🤔 생각의 흐름Disjoint Set 자료구조가 필요한 문제입니다. 귀찮은 부분은 이름이 숫자로 주어진 것이 아니라 문자열로 이루어진 점과 사람이총 몇 명인지 모르는 점입니다.문자열 이름은 딕셔너리를 이용해서 처리해주면 될 것 같네요. 처리해주는 방법은 디테일하게 2가지가 있습니다. 딕셔너리 key 값에 사람 이름을 담고, value 값으로 루트노드가 아니라면 부모의 이름을, 루트 노드라면 해당 tree 의 노드갯수를 저장하는 방법 딕셔너리 key 값에 사람 이름을 담고 value 값으로 리스트의 인덱스 번호를 저장하여, 리스트를 이용해 disjoint set 을구현하는 방법 설명은 1번 방법으로 설명하겠습니다만 코드는 1번 풀이와 2번 풀이 둘 다 작성하였습니다.🎯 풀이방법Disjoint Set 문제입니다. disjoint_set : 딕셔너리로 이루어진 Disjoint Set 자료구조. key 에는 사람의 이름이, value 에는 자식노드라면부모 이름, 부모노드라면 해당 트리의 원소 갯수가 담깁니다. union(a, b) : disjoint_set 에서 a 를 b 의 자식으로 합치는 함수입니다. b 는 노드 갯수가 증가하며 a 는 value 값이b로 바뀝니다. find(a) : disjoint_set 에서 a 의 루트노드를 찾아주는 함수입니다. disjoint set 을 위한 딕셔너리를 만들어줍니다. 2명씩 사람 이름을 입력받습니다. 만약 처음 입력받는 이름이라면 disjoint set 딕셔너리에 1 값을 value 로 갖도록넣어주어 루트노드로 만들어줍니다. 두 사람의 루트노드를 find 함수를 이용해 구해줍니다. 동일한 루트 노드를 가지는 경우, 아무것도 해주지 않습니다. 다른 루트노드를 가진 경우, 노드의 갯수가 적은 트리를 더 많은 트리로 합쳐줍니다. 3번을 수행한 후 루트노드의 value 값을 출력해줍니다.🔎 유의할 점 동일한 루트를 갖는 사람들을 입력받은 경우 union 을 해주면 안됩니다. (해줬을 때 메모리초과가 나오더라구요.) union 이나 find 함수를 재귀함수로 구현하는 경우, 재귀함수의 깊이가 1000이 넘어갈 수 있으니setrecursionlimit 으로 재귀함수 깊이를 높여주어야 합니다. 💻 코드딕셔너리만 이용from sys import stdininput = stdin.readlinedef solve(): TC = int(input()) # a를 b의 자식으로 연결 def union(a, b): disjoint_set[b] += disjoint_set[a] disjoint_set[a] = b return disjoint_set[b] def find(a): while isinstance(disjoint_set[a], str): a = disjoint_set[a] return a for _ in range(TC): F = int(input()) # 자식이름: 부모이름 or 집합 갯수 disjoint_set = {} for _ in range(F): a, b = input().split() if a not in disjoint_set: disjoint_set[a] = 1 if b not in disjoint_set: disjoint_set[b] = 1 a, b = find(a), find(b) if a == b: print(disjoint_set[a]) else: a_val, b_val = disjoint_set[a], disjoint_set[b] if a_val &gt; b_val: print(union(b, a)) else: print(union(a, b))if __name__ == '__main__': solve()리스트도 이용from sys import stdininput = stdin.readlinedef solve(): TC = int(input()) # a를 b의 자식으로 연결 def union(a, b): disjoint_set[b] += disjoint_set[a] disjoint_set[a] = b return -disjoint_set[b] def find(a): while disjoint_set[a] &gt;= 0: a = disjoint_set[a] return a for _ in range(TC): F = int(input()) disjoint_set = [] name = {} for _ in range(F): a, b = input().split() if a not in name: name[a] = len(name.keys()) disjoint_set.append(-1) if b not in name: name[b] = len(name.keys()) disjoint_set.append(-1) a, b = find(name[a]), find(name[b]) if a == b: print(-disjoint_set[a]) elif a &lt; b: print(union(b, a)) else: print(union(a, b))if __name__ == '__main__': solve()" }, { "title": "[백준 18809] Gaaaaaaaaaarden (파이썬 / Python)", "url": "/posts/boj-18809/", "categories": "알고리즘, 백준", "tags": "알고리즘, 백준, 구현, Brute Force, BFS", "date": "2022-04-17 12:33:00 +0900", "snippet": "📑 문제문제링크 : Gaaaaaaaaaarden🤔 생각의 흐름풀기 위해 아이디어적 어려움을 느낄만한 부분은 크게 없는 것 같습니다. 배양액을 뿌릴 수 있는 위치들 중에서 서로다른 R 개와 G 개를 뽑아BFS 를 수행해야합니다.다만 좀 귀찮은 부분은 빨간색과 초록색 배양액의 BFS 를 병렬적으로 수행해야하는 부분입니다. 처음에는 visited 리스트에방문한 위치를 boolean 으로 기록하고 각 배양액이 동시에 도달한 위치를 set 을 이용한 큐로 풀었습니다만 풀이가 많이느렸습니다.다른 분의 코드를 참고하여 입력받은 정원에 기록하는 방법을 알게되었습니다. 빨간색 배양액이 퍼질 자리에 +(현재 BFS 단계)를기록하고 초록색 배양액이 퍼질 자리에는 -(현재 BFS 단계)를 기록합니다. 만약 초록색 배양액이 퍼질 자리에 현재 BFS 단계와같은 수가 기록되어 있다면 동일한 단계에 퍼진 것이므로 꽃의 수를 +1 해주는 방식으로 빠르게 풀 수 있었습니다.🎯 풀이방법Brute Force, BFS, 구현 문제이며, 시간복잡도는 $O(2^{R+G} N M)$ 입니다. arr : 1차원 리스트로 입력받은 정원 spot : 배양액이 뿌려질 수 있는 위치 r_spot, g_spot : BFS 를 수행하기 위한 큐 step : BFS 의 단계 (2부터 시작) 정원을 입력받아 배양액이 뿌려질 수 있는 위치를 모두 알아내고, 그 위치들의 값을 2에서 1로 바꾸어줍니다.(BFS 를 수행할 때 1인 칸으로만 배양액이 퍼질 수 있도록 하기 위해서입니다.) 재귀함수나 itertools 의 combinations 를 이용하여 배양액이 뿌려질 위치에서 R 개와 G 개를 뽑아 각 큐에 넣어줍니다.(제 코드에서는 combinations 를 이용하였습니다.) BFS 수행을 위한 정원을 입력받은 정원을 복사하여 만듭니다. 빨간색 배양액이 있는 자리에서 현재 칸이 0 이상이라면(초록 배양액이 퍼진 자리는 음수로 기록되기 때문에)상하좌우 인접한 칸의 값이 1인 곳(다른 배양액이 도달하지 않은 자리)으로 퍼져나가며, 퍼진 칸에는 +(현재 BFS 단계)를 기록합니다.그리고 퍼진 칸을 큐에 넣어줍니다. 초록색 배양액이 있는 자리에서 상하좌우 인접한 칸의 값이 1인 곳 또는 현재 BFS 단계와 같은 값인 곳으로 퍼져 나갑니다. 값이 1인 칸으로 퍼진 경우 해당 칸에 -(현재 BFS 단계)를 기록하며 큐에 넣어줍니다. 값이 현재 BFS 단계와 동일한 칸으로 퍼진 경우 현재 BFS 의 꽃의 수를 +1 해주고, 해당 칸에 -(현재 BFS 단계)를 기록해줍니다. 초록색과 빨간색 배양액이 모두 큐에 남아 있는동안 BFS 를 계속 수행합니다. 가능한 모든 조합에 대해 BFS 를 수행하여가장 많은 꽃이 핀 경우의 값을 return 해줍니다.🔎 유의할 점 배양액을 뿌릴 수 있는 자리를 모두 알아낸 후 1로 바꾸어주거나, step 을 3부터 시작하고 배양액이 퍼질 자리의 값이1 또는 2인지 확인해주어야 합니다. 저의 코드는 전자로 구현했습니다. 새로운 BFS 를 수행할 때마다 초기에 입력받은 정원을 그대로 사용하는 것이 아닌, 복사 후 사용해주어야 합니다. 💻 코드from sys import stdinfrom itertools import combinationsinput = stdin.readlinedef solve(): N, M, G, R = map(int, input().split()) _len = N * M arr = [0] * _len idx = 0 for i in range(N): arr[idx:idx+M] = [*map(int, input().split())] idx += M spot = [x for x, y in enumerate(arr) if y == 2] for pos in spot: arr[pos] = 1 ans = 0 for _spot in combinations(spot, G + R): _spot = set(_spot) for r_spot in combinations(_spot, R): r_spot = [*r_spot] g_spot = list(_spot - set(r_spot)) _arr = [*arr] for r in r_spot: _arr[r] = 0 for g in g_spot: _arr[g] = 0 ans_val = 0 step = 2 while g_spot and r_spot: if g_spot: new_g_spot = [] for g in g_spot: if 0 &lt;= _arr[g]: x, y = g // M, g % M adj = [g - M if 0 &lt; x else -1, g + M if x &lt; N - 1 else -1, g - 1 if 0 &lt; y else -1, g + 1 if y &lt; M - 1 else -1, ] for nxt in adj: if nxt != -1: if _arr[nxt] == 1: new_g_spot.append(nxt) _arr[nxt] = step g_spot = new_g_spot if r_spot: new_r_spot = [] for r in r_spot: x, y = r // M, r % M adj = [r - M if 0 &lt; x else -1, r + M if x &lt; N - 1 else -1, r - 1 if 0 &lt; y else -1, r + 1 if y &lt; M - 1 else -1, ] for nxt in adj: if nxt != -1: if _arr[nxt] == step: ans_val += 1 _arr[nxt] = -step elif _arr[nxt] == 1: _arr[nxt] = -step new_r_spot.append(nxt) r_spot = new_r_spot step += 1 if ans &lt; ans_val: ans = ans_val return ansif __name__ == '__main__': print(solve())" }, { "title": "[백준 17435] 합성함수와 쿼리 (파이썬 / Python)", "url": "/posts/boj-17435/", "categories": "알고리즘, 백준", "tags": "알고리즘, 백준, 희소 배열", "date": "2022-04-16 15:30:00 +0900", "snippet": "📑 문제문제링크 : 합성함수와 쿼리🤔 생각의 흐름얼마 전에 알게된 희소 배열 알고리즘을 써야겠다고 생각했습니다.‘희소 배열이 뭐지?’ 하시는 분들은 이 글을 보고 와주세요.🎯 풀이방법희소 배열 문제이며, 시간복잡도는 $O((m + Q) \\log N)$ 입니다. move[i][j] : j 번 노드가 $2^i$ 번 이동했을 때의 위치 희소 배열 알고리즘을 위한 전처리를 해줍니다. 입력받은 쿼리를 전처리한 리스트를 이용하여 구합니다. 🔎 유의할 점 희소 배열 알고리즘을 이해하고 푼다면 크게 유의할 점은 없습니다.💻 코드from sys import stdininput = stdin.readlinedef solve(): m = int(input()) # log2(500_000) + 1 = 19 length = 19 # move[i][j]: f_2^i(j) move = [[0] * (m + 1) for _ in range(length)] move[0][1:m+1] = [*map(int, input().split())] for i in range(1, length): for j in range(1, m + 1): move[i][j] = move[i-1][move[i-1][j]] Q = int(input()) for _ in range(Q): n, x = map(int, input().split()) idx = 0 while (1 &lt;&lt; idx) &lt;= n: if n &amp; (1 &lt;&lt; idx): x = move[idx][x] idx += 1 print(x)if __name__ == '__main__': solve()" }, { "title": "[알고리즘] 희소 배열(Sparse Table) 알고리즘", "url": "/posts/theory-sparse-array/", "categories": "알고리즘, 이론", "tags": "알고리즘, 희소 배열, 자료구조", "date": "2022-04-16 15:24:00 +0900", "snippet": "🤔 희소 배열이 뭐야?희소 배열의 정의는 배열 원소의 갯수가 배열의 길이보다 작은 배열이라고 합니다.그런데 제가 설명할 알고리즘에서는 배열의 원소 갯수가 배열의 길이와 같은데 어째서 희소 배열인지는 잘 모르겠네요…이 알고리즘은 노드당 out-degree(나가는 간선의 갯수)가 1인 단방향 그래프에서,i 번 노드로부터 N 번 이동했을 때 어떤 노드에 도달하는지 알아내는데 매우 유용합니다.📃 희소 배열 알고리즘그냥 구하면 안돼?N 개의 노드들에 대해 M 번 이동 후 위치를 묻는다고 해봅시다. 그냥 구하게된다면 이 때의 시간복잡도는$O(N M)$일 것입니다. 만약 N 과 M 이 100,000이라면 N*M = 100억입니다. 그냥 구하기엔 너무 비효율적이죠.알고리즘 설명알고리즘의 핵심은 미리 $1, 2, 4, 8, …, 2^n$ 번 이동했을 때의 위치를 미리 구하고 쿼리를 수행하는 것입니다.기본적인 아이디어위와 같은 그래프가 있다고 해봅시다. 모든 그래프의 out-degree 는 1이고 단방향 그래프입니다.이 때 8번 노드로부터 7번 이동하는 경우를 생각해봅시다.\\[7 = 4 + 2 + 1\\]7번 이동 후 위치는 4번 이동, 2번 이동, 1번 이동 후의 위치와 같습니다. 1. 8번 노드에서 4번 이동하면 2번 노드입니다. 2. 2번 노드에서 2번 이동하면 4번 노드입니다. 3. 4번 노드에서 1번 이동하면 5번 노드입니다.7 번 이동 후 위치를 3번만에 알 수 있네요. 이 때문에 쿼리를 수행하기 전 미리 각 노드에서 $2^n$번 이동 후의 위치를 계산해 놓아야합니다.N 개 노드의 M 번 후 위치를 알아야 한다면 전처리에 $O(N \\log M)$ 만큼의 시간/공간을 소요하고 쿼리당 $O(log M)$ 의 시간을 소요합니다.전처리 n($2^n$) \\ 노드 1 2 3 4 5 6 7 8 9 10 11 n = 0 (1) 2 3 4 5 1 5 6 6 4 11 10 n = 1 (2) 3 4 5 1 2 1 5 5 5 10 11 n = 2 (4) 5 1 2 3 4 3 2 2 2 10 11 M 번 이동 후 위치까지 알아야한다면, 위와 같은 배열/리스트를 n = 0 부터 n = $[\\log_2 M]$ 까지 미리 만들어 두어야 합니다.만드는 방법은 간단합니다. $f_n (x) = (x$번 노드에서 $2^n$번 움직인 후 위치$)$라고 하면\\[f_n (x) = f_{n-1} (f_{n-1} (x))\\]입니다. 예를들어 1번 노드에서 2번 이동, 9번 노드에서 4번 이동 후 위치를 생각해보겠습니다.\\[f_1 (1) = f_0 (f_0 (1)) = f_0 (2) = 3\\]\\[f_2 (9) = f_1 (f_1 (9)) = f_1 (5) = 2\\]따라서 1번 노드에서 2번 이동 후 3번 노드, 9번 노드에서 4번 이동 후 2번 노드임을 알 수 있습니다.이렇게 n = 0 부터 n = $[\\log_2 M]$ 까지 만들면 됩니다.쿼리 수행쿼리 수행도 어렵지 않습니다. 이동해야하는 횟수 M 을 2의 거듭제곱꼴인 수들의 합으로 나타내주면 됩니다.위에서 7 = 4 + 2 + 1 로 쪼갰던 것처럼요. 어떻게 쪼갤 수 있을까요?\\[7 = 111_{(2)} = 4 + 2 + 1\\]\\[13 = 1101_{(2)} = 8 + 4 + 1\\]\\[21 = 10101_{(2)} = 16 + 4 + 1\\]감이 오시나요? i 번째 비트가 켜져있다면 $2^i$ 번 이동해주어야 합니다. while 문을 돌면서 켜져있는 비트일 때마다전처리 리스트를 이용해 구해나가면 됩니다.💻 코드1-based 그래프인 경우의 코드입니다. 노드 갯수: N 최대 이동 수: M arr[i]: i 번 노드의 1번 이동 후 위치from math import log2log2_m = log2(M)sparse_table = [[0] * (N + 1) for _ in range(log2_m + 1)]def build_sparse_table(): # 1번 이동 후 sparse_table[0] = arr for i in range(1, log2_m + 1): for j in range(1, N + 1): sparse_table[i][j] = sparse_table[i-1][sparse_table[i-1][j]]# x 노드의 m번 이동 후 위치def query(m, x): bit = 0 while (1 &lt;&lt; bit) &lt;= n: if n &amp; (1 &lt;&lt; bit): x = sparse_table[bit][x] bit += 1 return x참고capo님 블로그,남남서님 블로그" }, { "title": "[백준 2213] 트리의 독립집합 (파이썬 / Python)", "url": "/posts/boj-2213/", "categories": "알고리즘, 백준", "tags": "알고리즘, 백준, 트리", "date": "2022-04-15 13:22:00 +0900", "snippet": "📑 문제문제링크 : 트리의 독립집합🤔 생각의 흐름처음에는 각 노드마다 선택했을 때와 선택하지 않았을 때,두 경우의 해당 노드부터 leaf 노드까지의 가중치 합을 저장하는 dp 리스트에 저장하여 해결했습니다.하지만 다른 분의 풀이를 보니 굳이 dp 리스트를 사용하지 않고, 노드에 방문할 때마다 선택했을 때와 선택하지 않았을 때를함께 계산해 나가며 풀었습니다. 이 때의 로직과 코드가 더 간단했습니다.🎯 풀이방법트리 문제이며, 시간복잡도는 $O(N)$ 입니다. arr : 가중치 리스트. 1-based 로 저장하기 위해 맨 앞에 0을 추가했습니다. tree : 각 노드와 연결되어있는 다른 노드가 저장되는 2차원 리스트. 입력받으면서 어떤 노드가 부모노드인지알 수 없으므로, 입력받은 두 노드 모두에 서로를 추가해줍니다. visited : 어떤 노드가 부모노드인지 알기 위해 선언한 boolean 리스트입니다. 재귀적으로get_ans 함수를 호출할 때, 이미 도달했던 노드가 부모노드이므로 tree[idx] 중 방문하지 않은 노드들이 자식노드입니다. get_ans(idx) : 부모노드(idx)를 인자로 받아, idx 노드가 선택되었을 때와 안되었을 때,idx 노드부터 leaf 노드까지의 가중치의 합과 포함되는 노드들을 담은 리스트를 반환해주는 함수입니다. 가중치를 입력받아 1-based 로 저장해줍니다. 간선들을 입력받습니다. 모든 간선들을 입력받기 전까지는 트리가 어떻게 구성되어있는지 알 수 없으므로,그래프를 입력받듯이 두 노드에 연결된 노드로 서로를 추가합니다. 부모노드에서 자식노드 방향으로 가중치와 독립집합을 계산해 나가야 합니다. 현재 노드가 선택되었을 경우와 안되었을 경우에 따라 행동이 달라집니다. 현재 노드가 선택되었다면 모든 자식노드들은 선택되어서는 안됩니다. 따라서 현재 노드의 가중치와 (선택하지 않은 상태의 자식노드들 ~ leaf 노드의 가중치 합) 을더한 값이 현재 노드를 선택했을 때 현재노드 ~ leaf 노드까지의 가중치의 합이 됩니다. 현재 노드가 선택되지 않았다면 자식 노드들을 선택해도 되고 선택하지 않아도 됩니다. 이 때는 각 자식 노드를 선택했을 때와 선택하지 않았을 때,두 경우 중 가중치의 합이 더 높은 것을 골라서 더해주면 현재 노드를 선택하지 않았을 때 현재노드 ~ leaf 노드까지의 가중치의 합이 됩니다. 독립집합의 경우 현재 노드가 선택되었는지 안되었는지 나누어서 생각해야 합니다. 현재 노드가 선택된 경우 독립집합에 현재 노드를 추가해야합니다. 그리고 선택하지 않은 자식 노드 ~leaf 노드까지의 독립집합을 현재 독립집합에 추가해줍니다. 현재 노드가 선택되지 않았을 경우, 자식을 선택했을 때와 선택하지 않았을 때의 가중치 합이 더높은 쪽의 자식 ~ leaf 노드까지의 독립집합을 현재 독립집합에 추가해줍니다. 4번과 5번에서 구한 가중치와 독립집합들을 return 해줍니다. (4번과 5번 동작을 해주는 함수가 get_ans 함수입니다.) 1번 노드를 루트노드로 설정하여 가중치와 독립집합을 get_ans 함수를 이용하여 구하고 출력해줍니다.🔎 유의할 점 간선들을 다 입력받기 전까지는 어떤 노드가 부모 노드고 자식 노드인지 온전히 알기는 어렵습니다.그래서 입력을 다 받은 후 루트노드부터 자식노드까지 tree 를 파악하고 탐색을 시작하거나,방문여부를 저장한 boolean 리스트를 이용해 탐색해가며 어떤 노드가 부모노드이고 자식노드인지 파악해야 합니다. 마지막 독립집합의 노드들을 출력할 때 정렬을 한 후 출력해주어야 합니다. 💻 코드from sys import stdininput = stdin.readlinedef solve(): N = int(input()) arr = [0, *map(int, input().split())] tree = [[] for _ in range(N + 1)] for _ in range(N-1): a, b = map(int, input().split()) tree[a].append(b) tree[b].append(a) visited = [False] * (N + 1) def get_ans(idx): visited[idx] = True sel_w, nsel_w = arr[idx], 0 sel_n, nsel_n = [idx], [] for nxt in tree[idx]: if not visited[nxt]: w_sel, w_nsel, n_sel, n_nsel = get_ans(nxt) sel_w += w_nsel sel_n += n_nsel if w_sel &gt; w_nsel: nsel_w += w_sel nsel_n += n_sel else: nsel_w += w_nsel nsel_n += n_nsel return sel_w, nsel_w, sel_n, nsel_n wa, wb, na, nb = get_ans(1) if wa &gt; wb: print(wa) print(*sorted(na)) else: print(wb) print(*sorted(nb))if __name__ == '__main__': solve()" }, { "title": "[백준 1007] 벡터 매칭 (파이썬 / Python)", "url": "/posts/boj-1007/", "categories": "알고리즘, 백준", "tags": "알고리즘, 백준, 수학, Brute Force", "date": "2022-04-14 18:18:00 +0900", "snippet": "📑 문제문제링크 : 벡터 매칭🤔 생각의 흐름고등학교 때 배웠던 벡터를 생각해봅시다. 벡터는 $\\vec {AB} = B - A$ 로 표현할 수 있으며, 벡터 2개의 합은\\[\\vec {AB} + \\vec {CD} = (B - A) + (D - C)\\]\\[= (B + D) - (A + C)\\tag{1}\\]\\[= (A + B + C + D) - 2 (A + C)\\tag{2}\\]으로 표현할 수 있습니다. 즉, 모든 점을 더한 뒤 2 * (두 점의 합) 을 빼주는 것으로 두 벡터의 합을 구할 수 있습니다. 잠깐! 그냥 1 번 식처럼 (절반의 점들의 합) - (나머지 점들의 합) 으로 구하면 안되나요? 1번 식으로 풀어도 됩니다만, 코딩을 하다보니 2번 식으로 구현하는게 더 수월하더라구요.이제 문제에 대해 생각해봅시다. $N \\leq 20$ 이므로 점들은 최대 20개입니다. ans = min((N 개의 점들을 더한 값) - 2 * (N/2 개의 점들을 더한 값)) 으로생각할 수 있겠네요. 그리고 N 개의 점들 중 N/2 개의 점을 선택하는 횟수는 ${N \\choose N/2}$ 입니다.🎯 풀이방법수학, Brute Force 문제입니다. x, y : 점들의 x 좌표와 y 좌표를 저장하는 리스트 tx, ty : 입력받은 x 좌표와 y 좌표들의 합 combi(cnt, idx, sx, sy) : 벡터 합의 길이의 최솟값을 ans 에 저장하는 재귀함수 cnt : N / 2 개의 점을 선택하는데 남은 점들의 갯수 idx : 몇 번 째 점들부터 선택해야 하는지. sx, sy : 선택한 점들의 합 점을 입력받으며 x 좌표와 y 좌표의 총합을 구합니다. 재귀함수(combi 함수)를 이용하여 N/2 개의 점들을 선택하여 선택한 좌표들의 합을 구합니다. (점들의 총합) - (선택한 점들의 합) 을 구하여 벡터의 길이를 구합니다. 구한 길이가 ans 보다 작다면 ans 를 갱신합니다. 선택할 수 있는 모든 경우를 선택한 후의 ans 를 출력해줍니다. 🔎 유의할 점 구해야하는 것은 벡터 길이의 합이 아닌 벡터 합의 길이입니다.💻 코드from sys import stdininput = stdin.readlinedef solve(): TC = int(input()) inf = float('inf') x, y = [0] * 20, [0] * 20 ans, tx, ty = inf, 0, 0 def combi(cnt, idx, sx, sy): nonlocal ans if cnt == 0: tmp = ((tx - 2 * sx) ** 2 + (ty - 2 * sy) ** 2) ** 0.5 if tmp &lt; ans: ans = tmp else: for i in range(idx, N - cnt + 1): combi(cnt-1, i+1, sx+x[i], sy+y[i]) for _ in range(TC): N = int(input()) ans, tx, ty = inf, 0, 0 for i in range(N): x[i], y[i] = map(int, input().split()) tx += x[i] ty += y[i] combi(N//2 - 1, 1, x[0], y[0]) print(ans)if __name__ == '__main__': solve()" }, { "title": "[백준 9328] 열쇠 (파이썬 / Python)", "url": "/posts/boj-9328/", "categories": "알고리즘, 백준", "tags": "알고리즘, 백준, 구현, BFS, DFS", "date": "2022-04-14 16:23:00 +0900", "snippet": "📑 문제문제링크 : 열쇠🤔 생각의 흐름visited 리스트에 키 상태를 저장해가며 DFS 를 진행하려고 했습니다. 키 상태는 비트마스크를 이용하여,이전에 방문했던 칸에 다시 도착하더라도 visited 에 저장되어 있는 키 상태와 다르다면 스택에 집어넣는 방식으로 구현하려고 했습니다.그런데 풀다보니 코드도 복잡해지고 예외처리도 귀찮아지며, 왔던 칸을 다시 방문해야하는 일이 빈번히 일어난다면 느릴 것 같았습니다.그래서 visited 는 boolean 으로 방문여부를 저장하도록 바꾸었습니다. ‘A’ ~ ‘Z’ 가 인덱스 0 ~ 25 에 매칭되는stuck 리스트를 만들어줍니다. 문에 도착했을 때 해당 문을 열 수 있는 열쇠가 없다면 stuck 리스트에 문의 위치를 저장하고,열쇠가 있다면 BFS(DFS) 를 진행해주는 큐(스택)에 문의 위치를 넣어줍니다.🎯 풀이방법구현, BFS, DFS 문제이며, 시간복잡도는 $O(h w)$ 입니다. arr : 지도 adj(pos) : pos 의 상하좌우를 반환해주는 제너레이터 entrance() : 벽이 아닌 가장자리의 위치를 반환해주는 제너레이터 visit(pos) : 위치 pos 에 도착했을 때 visited 에 기록하고, pos 에 있는 문자에 따라 적절한 행동을 해주는 함수. . or $ : 다음 BFS(DFS) 에 탐색할 수 있도록 pos 를 큐(스택)에 넣어준다. a ~ z : 열쇠 k를 얻었다고 하면, key[k] = True 를 해주고, stuck[K] 에 저장된 위치들을 큐(스택)에 넣어준다. 그리고 pos 를 큐에 넣어준다. A ~ Z : 문 K라고 하면 key[k] == True 인지 확인하여, True 일 경우 pos 를 큐(스택)에 넣어주고, False 라면 pos 를 stuck[K] 에 넣어준다. * : 벽은 아무것도 해주지 않습니다. key : ‘a’를 0, ‘z’를 25 에 매칭시켜 가지고 있는 키를 boolean 으로 기록하는 리스트 stuck : 열쇠가 없어 나아가지 못하는 문의 위치가 저장되어있는 2차원 리스트 지도와 열쇠를 입력받고, 열쇠가 있다면 key 리스트에 해당 열쇠를 True 로 만들어줍니다. 벽이 아닌 가장자리에서 시작하여 BFS(DFS) 를 진행합니다. 해당 입구에 방문한 적이 없다면 입구의 문자에 따라 적절한 행동(visit 함수)을 취한 뒤, 큐(스택)에 넣고 BFS(DFS) 를 시작합니다. 방문한적 있다면 다음 입구에서 2번 단계를 수행합니다. 큐(스택)에서 원소를 꺼내어 해당 위치에 문서가 있다면 ans + 1 을 해줍니다. 그리고 상하좌우 이동할 수 있는 위치에 대해 적절한 행동(visit 함수)을 취해줍니다. 벽이 아닌 모든 가장자리부터 2 ~ 3 번 단계를 수행하였다면 ans 를 출력해줍니다. 🔎 유의할 점 입구에 있는 것도 올바르게 처리해주어야 합니다. 제가 입구에 있는 문자를 처리해주지 않아서 계속 틀렸습니다…💻 코드from sys import stdininput = stdin.readlinedef solve(): def adj(pos): r, c = pos // w, pos % w if 0 &lt; r: yield pos - w if r &lt; h - 1: yield pos + w if 0 &lt; c: yield pos - 1 if c &lt; w - 1: yield pos + 1 def entrance(): for i in range(w): if arr[i] != '*': yield i idx = w for i in range(h - 2): if arr[idx] != '*': yield idx idx += w - 1 if arr[idx] != '*': yield idx idx += 1 for i in range(idx, _len): if arr[i] != '*': yield i # $: 36 / .: 46 / A: 65 / Z: 90 / a: 97 / z: 122 def visit(pos): _pos = ord(arr[pos]) # 빈 공간 or 문서 if _pos &lt;= 46: que.append(pos) visited[pos] = True # 문 elif _pos &lt;= 90: d = _pos - 65 if key[d]: que.append(pos) else: stuck[d].append(pos) visited[pos] = True # 열쇠 else: k = _pos - 97 if not key[k]: key[k] = True que.extend(stuck[k]) que.append(pos) visited[pos] = True for _ in range(int(input())): h, w = map(int, input().split()) _len = h * w arr = '' for _ in range(h): arr += input()[:-1] key_str = input()[:-1] key = [False] * 26 if key_str != '0': for k in key_str: key[ord(k) - 97] = True stuck = [[] for _ in range(26)] visited = [False] * _len ans = 0 # entrance() 에서 가능한 입구만 yield 해준다 for e in entrance(): if not visited[e]: que = [] visit(e) while que: pos = que.pop() # 문서인 경우 if arr[pos] == '$': ans += 1 for nxt in adj(pos): if arr[nxt] != '*' and not visited[nxt]: visit(nxt) print(ans)if __name__ == '__main__': solve()" }, { "title": "다크모드 VS 라이트모드 - (2)설계 및 개발 / [작성 중]", "url": "/posts/project-dark-vs-light-2/", "categories": "프로젝트, NextJS", "tags": "프로젝트, NextJS, 리액트, TypeScript, 라이트모드, 다크모드", "date": "2022-04-13 22:16:00 +0900", "snippet": " 2022년 1학기 HCI 수업의 과제로 진행한 프로젝트입니다. NextJS를 이용하여 개발하였습니다. 링크 : 다크모드 VS 라이트모드, 어떤게 더 좋을까?👨‍💼 개발에 앞서 받은 교수님의 피드백다크모드와 라이트모드 중 어떤 모드가 나은지 비교하는 주제의 프로젝트의 컨셉을 발표했습니다.다크모드와 라이트모드를 번갈아가며 비슷한 단어들을 나열하고 제시한 단어와 일치하는 단어를 고르는 테스트를 만들겠다고 발표했습니다.이 프로젝트 컨셉을 들은 교수님께서 피드백을 해주셨습니다. 1. 정확도와 함께 시간도 측정했으면 좋겠다. 정확도와 속도가 trade off 관계임을 확인해봤으면 좋겠다. 2. 다양한 연령대의 유저를 확보했으면 좋겠다.처음에는 정확도만 측정하려고 했지만, 속도와의 관계를 파악하기 위해 제한시간 없이 고르는 문제와제한시간 내에 고르는 문제, 두 가지 타입의 문제를 만들기로 했습니다.🧱 첫 설계📑 전체적인 흐름stateDiagram-v2 direction LR [*] --&gt; 정상흐름 state 정상흐름 { 홈 --&gt; 주로&amp;nbsp;사용하는&amp;nbsp;테마고르기 주로&amp;nbsp;사용하는&amp;nbsp;테마고르기 --&gt; 제한시간없이&amp;nbsp;문제풀기 제한시간없이&amp;nbsp;문제풀기 --&gt; 제한시간&amp;nbsp;내&amp;nbsp;문제풀기 제한시간&amp;nbsp;내&amp;nbsp;문제풀기 --&gt; 설문 설문 --&gt; 결과 } 정상흐름 --&gt; 리다이렉션 : 비정상적 이동 리다이렉션 --&gt; 정상흐름 정상흐름 --&gt; [*]전체적인 흐름입니다. 초반에 주로사용하는 모드를 입력받습니다. 후반부의 설문에서 받을 수도 있지만 먼저 묻는 이유는,테스트를 진행할 때, 주로 사용하는 모드에서 문제를 먼저 풀고 그 후에 반대모드에서 문제를 풀게 만들기 위함입니다.문제는 위에서 말했다시피 2가지 타입의 문제가 있습니다. 먼저 제한시간 없이 고르는 문제를 풀고, 그 후에제한시간 내에 고르는 문제를 풉니다. 그리고 각 타입에는 총 6개의 문제가 있습니다.다크모드와 라이트모드 각각에서 3개씩 풀게됩니다.모든 문제를 다 풀고나면 설문을 하게됩니다. 설문에서는 유저스터디에 필요하다고 생각되는 정보들을 묻습니다.설문을 모두 작성한 후 결과보기를 하면 유저의 테스트 정보와 설문의 내용이 Firebase 에 저장됩니다.📝 문제 설계문제를 설계함에 있어서 고려해야할 점이 몇 가지 있었습니다. 1. 각 문제타입(제한시간 없는 타입과 있는 타입)에 몇 문제씩 할 것인가 2. 문제 하나 당 나열할 단어의 갯수와 답의 갯수 3. 어떤 단어를 제시어로 할 것이며, 비슷한 단어들을 어떻게 만들 것인가 4. 시간제한은 몇 초로 둘 것인가 5. 문제와 문제 사이의 여유시간 확보 방법 6. 폰트 각 문제타입에서 다크모드 3문제, 라이트모드 3문제씩 풀도록 했습니다. 3문제인 이유는 폰트굵기에 따라가독성이 달라질 수 있다고 생각했습니다. 폰트굵기가 light, regular, bold, 3 경우일 때 어떻게 다른지 측정하기 위해3문제씩 배치하였습니다. 문제의 갯수는 6의 배수로 하고 싶었습니다. 디자인상 컴퓨터와 태블릿에서는 6열, 스마트폰에서는 3열이 적당해보였기 때문입니다.다크모드와 라이트모드에서의 정확한 비교를 위해 최대한 동일한 환경을 만들고 싶었습니다. 그래서 답의 갯수를 항상 같게 만들고 싶었습니다.문제를 풀며 답이 몇 개인지 눈치채지 못하도록 적지 않으면서, 그렇다고 너무 많지 않게 갯수를 정해야 했고,답의 갯수를 7개로 하기로 했습니다. 단어의 총 갯수는 7의 약 4배이며 6의 배수인 30개로 정했습니다. 제시어는 2글자이면서 2글자 모두 종성까지 있는 단어를 골랐습니다. 또, 헷갈릴 여지가 높은 자음을 가진 단어를 골랐습니다.‘ㅁ, ㅂ’, ‘ㄹ, ㅌ, ㄷ’, ‘ㅈ, ㅊ’ 과 같이 비슷한 자음이 있어야 가독성을 측정할 수 있다고 판단했습니다.그래서 결국 고른 단어는 ‘범법’, ‘찍먹’, ‘꿀잼’ 이었으며 오답은 ‘법법’, ‘찍벅’, ‘꿀잽’ 과 같이 변화를 주어 만들었습니다. 제한시간은 처음부터 마지막 단어까지 빠르게 판단하며 답을 고르고, 마지막 단어에 대한 판단을 마친 직후에 제한시간이 끝나도록 설정하고 싶었습니다.사람들마다 보는 속도가 다르기 때문에 정확하게 설정할 수 없었습니다만, 여러 번 테스트한 결과 한 단어당 0.5초씩이 적당한 것 같았습니다.30 단어 * 0.5초 = 15초로 하여 시간제한은 15초로 설정하였습니다. 중간에 쉬는 시간 없이 연달아서 계속 문제를 풀기보다는, 유저가 준비되었을 때 풀기를 시작하는게 좋다고 판단했습니다.하지만 유저에게 “이미 문제 준비는 되어있고 너만 OK 하면 풀 수 있어!” 라는 느낌을 주고 싶었습니다.이 느낌과 유저의 준비시간을 단어에 blur 효과를 주는 방식으로 구현했습니다. 이 문제들을 푸는데 가독성이 좋은 폰트는 필수불가결한 요소로 생각하였습니다. 여러 폰트를 놓고 고민하였지만나무위키에서도 사용하며, 그 외에 여러 사이트에서 사용하는 나눔바른고딕을 사용하기로 하였습니다. ❓ 설문설문으로 조사받는 것은 위 사진과 같이 5가지로 설계하였습니다. 디바이스 : 사용하는 기기가 다양하다면 기기에 따라 어떤 모드가 더 나은지 알고 싶었습니다. 성별과 나이 : 성별과 나이에 따라 더 나은 모드가 다를지 궁금하였습니다. 어떤 모드에서 더 잘 읽혔나 : 정량적으로 측정한 결과와 사용자의 생각이 같을지 궁금하였습니다. 어떤 모드에서 덜 피로했나 : 테스트를 통해 피로도는 측정할 수 없으므로, 유저의 생각이라도 설문받았습니다. ❗ 결과🧱 두 번째 설계첫 번째 설계대로 개발 후 주변 지인들한테 피드백을 받아 몇 가지 설계를 수정했습니다." }, { "title": "[백준 17495] 피아노 연주 (파이썬 / Python)", "url": "/posts/boj-17495/", "categories": "알고리즘, 백준", "tags": "알고리즘, 백준, DP", "date": "2022-04-13 21:50:00 +0900", "snippet": "📑 문제문제링크 : 피아노 연주🤔 생각의 흐름예전에 학교 수업시간에 배웠던 Assembly Line Scheduling 이 떠올랐습니다.dp[i][j] = i 번째에 j 손(0: 왼손, 1: 오른손) 으로 쳤을 때 0번째부터의 거리 합으로 정의하고 풀었더니 틀렸습니다가 나왔습니다.테스트 케이스 생성하는 코드를 짜서 돌려봤더니 아래와 같은 반례들이 있었습니다.G2 D110A1# E1# G2# A2 D2 D0 A2 C2 E0 C0#G2# E1#5E0 B1 G2 G1 A0#Assembly Line Scheduling 알고리즘은 i 번째에서 (i+1) 번째로 넘어가는데 더해지는 값이 고정적이지만,이 문제는 i 번째에서의 손 위치가 이후에 더해지는 값들에도 영향을 주기 때문에 이 알고리즘을 이용할 수 없던 것으로 보입니다.그래서 다른 점화식을 세웠습니다. arr[i] 를 시간 i 에서 음, l 과 r 을 왼손과 오른손의 위치라고 할 때,\\[dp[i][l][r] = min(|arr[i] - l| + dp[i+1][arr[i]][r], |arr[i] - r| + dp[i+1][l][arr[i]])\\]이며, dp[i][l][r] 은 i 번째에서 왼손과 오른손이 l 과 r 에 있을 때, i 번째부터 마지막까지 연주했을 때의 최소 거리입니다.참고로 위 식에서 min 함수 안의 왼쪽은 왼손을 움직인 경우, 오른쪽은 오른손을 움직인 경우입니다.🎯 풀이방법DP 문제입니다. convert(a) : 음을 나타내는 문자열 a 를 입력받아 C0 = 0 을 기준으로 하여 정수로 변환해주는 함수 arr : 쳐야하는 음들을 저장한 리스트 dp[i][l][r] : 왼손과 오른손이 l 과 r 에 있을 때, i 번째부터 마지막까지 연주했을 때의 거리 calc(depth, left, right) : dfs 방식으로 dp[depth][left][right] 를 계산하고 dp 리스트에 저장하는 함수 초기 왼손의 위치(= l)과 오른손의 위치(= r)를 입력받아 정수로 변환합니다. 쳐야하는 음들을 입력받아 정수로 변환하여 리스트에 저장합니다. calc(depth=0, left=l, right=r) 을 호출하여 dp 리스트에 올바른 값을 할당해줍니다. calc 함수에서 위 점화식에 맞게, depth 번째에 왼손과 오른손을 각각 움직였을 때 중 거리의 최소를 구하여 dp리스트에 저장해줍니다. i = 0 부터 i = N - 1 까지 왼손과 오른손을 움직였을 때의 거리를 비교하여, 더 적은 손을 움직여가며 움직여야하는 손들을 출력합니다. 🔎 유의할 점 i 번째의 손의 위치에 따라 이후에 더해져야하는 값이 바뀔 수 있으므로, 이 문제에서는 Assembly Line Scheduling 을 쓸 수 없습니다. 점화식을 이해하고 푼다면 크게 유의해야할 부분은 없는 것 같습니다. 💻 코드from sys import stdin, setrecursionlimit as SRLSRL(10 ** 6)input = stdin.readlinedef solve(): conv = {'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11} def convert(a): return conv[a[0]] + int(a[1]) * 12 + (len(a) == 3) l, r = map(convert, input().split()) N = int(input()) arr = [*map(convert, input().split())] # dp[i][l][r]: i 번째에 왼손과 오른손이 l과 r에 있을 때, 마지막까지 연주하는 거리 dp = [[[-1] * 121 for _ in range(121)] for _ in range(N+1)] seq = [0] * N def calc(depth, left, right): if depth == N: return 0 elif dp[depth][left][right] != -1: return dp[depth][left][right] _l = abs(arr[depth] - left) + calc(depth+1, arr[depth], right) _r = abs(arr[depth] - right) + calc(depth+1, left, arr[depth]) dp[depth][left][right] = _l if _l &lt; _r else _r return dp[depth][left][right] calc(0, l, r) print(dp[0][l][r]) _l, _r = l, r for i in range(N): l_val = abs(_l - arr[i]) + dp[i+1][arr[i]][_r] r_val = abs(_r - arr[i]) + dp[i+1][_l][arr[i]] if l_val &lt; r_val: _l = arr[i] print(1, end=' ') else: _r = arr[i] print(2, end=' ')if __name__ == '__main__': solve()" }, { "title": "[백준 17071] 숨바꼭질 5 (파이썬 / Python)", "url": "/posts/boj-17071/", "categories": "알고리즘, 백준", "tags": "알고리즘, 백준, BFS", "date": "2022-04-12 11:40:00 +0900", "snippet": "📑 문제문제링크 : 숨바꼭질 5🤔 생각의 흐름방문한 칸에 다시 방문하지 않아도 되는 BFS 문제로 생각했습니다. 그런데 N = 3, K = 0 인 경우,K가 0 → 1 → 3 으로 변할 때, N이 3 → 2 → 3 이어야 최소가 됩니다. 경우에 따라 방문한 위치에 재방문해야하는경우가 있더라구요.그런데 방문한 위치에 다시 가려면 2초가 필요합니다. N + 1 혹은 N - 1 로 갔다가 다시 N 으로 와야하니까요.그래서 방문한 위치에 대한 기록을 짝수 초가 지났을 때와 홀수 초가 지났을 때, 2가지 경우로 나누어 생각해야 한다고 생각했습니다.홀수 초가 지났는데 이미 N 이 홀수 초에 방문했던 곳이라면, N 은 N + 1 이나 N - 1 로 갔다가 N 으로 돌아오는행동을 계속 방문하면서 기다리고 있으면 만날 수 있게되므로, 그 때의 BFS 단계가 답이 됩니다.🎯 풀이방법BFS 문제이며, 시간복잡도는 $O(500,000)$ 입니다. visited[i][j] : i = 0 인 경우 짝수초, i = 1 인 경우 홀수초. 위치 j 에 도착했을 때의 BFS 단계를 저장한 리스트 맨 처음에 N == K 라면 0 을 return 합니다. 초기위치 N을 큐에 넣고 K &lt;= 500,000 인 동안 BFS 를 진행합니다. 큐에 저장되어 있는 위치 pos 로부터, pos - 1, pos + 1, 2 * pos 가 구간 [0, 500,000] 에 있는지 확인하고,구간 안에 있다면 visited 리스트를 이용하여 이전에 현재와 같은 홀/짝 초에 방문한적 있는지 확인합니다. 방문한적 없다면 큐에 해당 위치를 넣어주고 visited 에 기록합니다. K 위치에 현재의 홀/짝 초에 N 이 방문한적 있는지 확인하고, 방문한적 있다면 현재의 BFS 단계를 return 합니다.방문한 적이 없다면 K 를 조건에 맞게 이동시켜주고 다음 BFS 단계를 수행합니다. K &lt;= 500,000 인 동안 만날 수 없었다면 -1 을 return 해줍니다. 🔎 유의할 점 이 문제는 방문한 위치에 다시 방문할 수 있습니다. 하지만 다시 방문하기 위해서는 2초가 필요하므로,짝수초와 홀수초로 나누어서 풀어야 합니다.💻 코드가독성이 좋은 코드from sys import stdininput = stdin.readlinedef solve(): N, K = map(int, input().split()) if N == K: return 0 visited = [[0] * 500_001 for _ in range(2)] que = [N] K += 1 ans, i = 1, 2 while K &lt;= 500_000: new_que = [] is_odd = i &amp; 1 for pos in que: for p in [pos - 1, pos + 1, 2 * pos]: if 0 &lt;= p &lt;= 500_000 and not visited[is_odd][p]: visited[is_odd][p] = ans new_que.append(p) que = new_que if visited[is_odd][K]: return ans ans += 1 K += i i += 1 return -1if __name__ == '__main__': print(solve())조금 더 빠른 코드from sys import stdininput = stdin.readlinedef solve(): N, K = map(int, input().split()) if N == K: return 0 ans = 1 visited = [[0] * 500_001 for _ in range(2)] que = [N] i = 2 K += 1 while K &lt;= 500_000: new_que = [] is_odd = i &amp; 1 for pos in que: # pos - 1 p = pos - 1 if 0 &lt;= p and not visited[is_odd][p]: visited[is_odd][p] = ans new_que.append(p) # 2 * pos &lt;= max_pos 인 경우, pos + 1 &lt;= max_pos 이다 p = 2 * pos if p &lt;= 500_000: # 2 * pos if not visited[is_odd][p]: visited[is_odd][p] = ans new_que.append(p) # pos + 1 p = pos + 1 if not visited[is_odd][p]: visited[is_odd][p] = ans new_que.append(p) # pos + 1 elif pos &lt; 500_000 and not visited[is_odd][pos + 1]: p = pos + 1 visited[is_odd][p] = ans new_que.append(p) que = new_que if visited[is_odd][K]: return ans ans += 1 K += i i += 1 return -1if __name__ == '__main__': print(solve())" }, { "title": "다크모드 VS 라이트모드 - (1)기획", "url": "/posts/project-dark-vs-light-1/", "categories": "프로젝트, NextJS", "tags": "프로젝트, NextJS, 리액트, TypeScript, 라이트모드, 다크모드", "date": "2022-04-11 22:16:00 +0900", "snippet": " 2022년 1학기 HCI 수업의 과제로 진행한 프로젝트입니다. NextJS를 이용하여 개발하였습니다. 링크 : 다크모드 VS 라이트모드, 어떤게 더 좋을까?💡 HCI, 지금까지의 수업과는 다르다!HCI는 Human Computer Interaction 의 약자로, 인간과 컴퓨터의 상호작용을 이야기합니다. 그리고 제가 2022학년도 1학기인 현재 듣고 있는 수업입니다.전부터 학교 수업을 듣고 과제를 하면서 드는 생각이 있었습니다. 학교 과제로는 현업에서 쓰는 것들을 이용한 과제는 없는걸까?그런데 이 수업의 과제는 학교에서 처음으로 만나본, 개발다운 과제였습니다. DBMS 수업을 들으며 만들었던 B+ Tree, Buffer, Transaction, Recovery 나,네트워크 수업을 들으며 만든 토렌트 등 도움되고 유익했으며 재밌는 과제는 많았지만, 항상 무언가 개발한다라고 말하기에는 애매한 느낌들의 과제였습니다.HCI 수업은 조금 달랐습니다. on time and within budget 을 강조하며 프로젝트를 각자 구상하고, 정해진 기간 내에 개발하여 유저테스트를 진행하는 수업이었습니다.지금까지 해온 과제 중에서 가장 자유도가 높으며 개발한다는 느낌을 주는 과제였습니다.🤔 그래서 뭘 개발해야하지저는 게임을 좋아합니다. 하지만 오픈월드류의 게임은 별로 좋아하지 않습니다. 그 이유는 높은 자유도 때문이죠.얘가 젤다 야숨을 안해봤네! 높은 자유도가 주는 갓겜인데 그거 하면 생각 달라질걸? 주변 사람들한테서 많이 들었습니다.실제로 닌텐도 스위치도 있고, 야숨도 샀는데 정작 플레이하지 않네요… 하지만 지금으로써는 높은 자유도가 저한테는 단점입니다.제게는 높은 자유도 = 뭘 할지 모르겠어! 이기 때문입니다.고민하던 와중 뜻밖의 영감이 찾아왔습니다. 핸드폰으로 다크모드를 이용해 웹서핑을 하던 중 저희 엄마께서그렇게 보면 눈 나빠져! 그리고 눈아프지 않니? 밝게 해서 봐야지! 라고 하셨습니다.웬만하면 다크모드를 즐겨쓰는 저로서는 좀 의아했습니다. 이러한 계기로 다크모드와 라이트모드 중어떤 모드가 더 나은지 직접 테스트하는 프로젝트를 하기로 했습니다.그런데 다크모드와 라이트모드 중 낫다라는 것은 무엇을 기준으로 판단할까요? 가독성이나 눈의 피로도 등,여러 요소가 판단 기준이 될 수 있겠지만, 이 프로젝트에서는 가독성에 초점을 맞추려고 했습니다.가독성은 특별한 장치 없이 정량적인 측정이 가능하지만, 눈의 피로도는 측정하기 힘들기 때문입니다.👨‍💻 앱으로 개발? 웹으로 개발?웹으로 개발할 때는 React 기반의 NextJS 를 이용하여 주로 개발하며, 앱을 개발할 때는 Flutter 로 개발합니다.두 가지 모두 가능하지만 이 프로젝트는 단기간 안에 많은 사람들이 할 수 있는 것이 목표입니다.이런 면에서 앱은 다운 받아 설치해야 하며, 애플의 경우 등록이 되기까지 시간이 오래 걸리기 때문에 컴퓨터, 스마트폰, 태블릿으로등의 기기에서 바로 할 수 있도록 웹으로 개발하기로 했습니다.👨‍👩‍👧‍👦 어떻게 해야 많은 사람들이 할까?어떤 주제로, 무엇을 이용해 개발할지 정했습니다. 이왕 개발하는거 당연히 많은 사람이 했으면 좋지 않겠어요?그래서 최대한 많은 사람들이 하게 만들기 위해서는 무엇이 필요할까 고민했습니다.그리고 다음 3가지가 필요하다고 결론내렸습니다. 1. 재미있어야 하며, 지루함은 최대한 없어야 한다. 2. 길지 않아야 하며, 루즈해질 때쯤 끝나야한다. 3. 유저도 얻는 것이 있어야한다.첫 번째로 재미를 위해서 게임이나 간단한 테스트 방식이 적합하다고 생각했습니다.그래서 생각한 방식이 여러 단어들 사이에서 제시한 단어와 일치하는 단어를 모두 고르기였습니다.게임 느낌의 테스트를 함으로써 사용자에게 조금이나마 재미를 느낄 수 있게 디자인했습니다.두 번째로 아무리 길어도 5분이 넘어가면 안된다고 생각했습니다. 간단한 테스트라도 너무 길면사람들이 중간에 하다가 그만둘 것이라고 생각했습니다. 3분에서 아무리 길어도 5분 이내로 끝낼 수 있게끔디자인하였습니다.세 번째로 유저도 얻는 것이 있어야한다고 생각했습니다. 유저들은 시간이 남아도는 자원봉사자가 아닙니다.그렇기 때문에 테스트를 끝까지 할 수 있게 만드는 원동력이 필요하다고 생각하였습니다.그 원동력을 유저가 진행한 테스트의 결과를 간단하게나마 분석하여, 각 개인에게 맞는 모드를 추천해주기로 하였습니다.🏆 높은 퀄리티와 많은 유저를 목표로교수님도 말씀하셨지만, 제가 생각해도 솔직히 거창한 프로젝트는 아닙니다. 오히려 쉽다고 할 수 있죠.그렇기 때문에 최대한 교수님이 첫 시간부터 강조하셨던 on time and within budget 을 지키며 높은 퀄리티로 개발하고,많은 사람들이 할 수 있는 프로젝트를 하고 싶었습니다. 지금 생각해보면 그런 면에서 나름 괜찮은 주제였던 것 같네요." }, { "title": "[백준 16933] 벽 부수고 이동하기 3 (파이썬 / Python)", "url": "/posts/boj-16933/", "categories": "알고리즘, 백준", "tags": "알고리즘, 백준, BFS", "date": "2022-04-11 19:30:00 +0900", "snippet": "📑 문제문제링크 : 벽 부수고 이동하기 3🤔 처음 생각전형적인 BFS 문제라고 생각했습니다. 그래서 visited[N * M][2] 크기의 2차원 리스트를 만들어서 풀 수 있겠지 생각했습니다.참고로 visited[N][M][2] 3차원 리스트로 하지 않은 이유는 차원을 낮추면 더 빠르지 않을까라는 생각이었습니다만, 이번처럼 N * M 이 큰 경우에는 더 느리더군요.그런데 시간초과가 나오더라구요. 지금 생각해보면 3차원 리스트로 풀었으면 시간초과가 나지는 않았을 것 같지만, 그 당시에는 더 빠른 방법이 존재한다고 생각했고다른 방법을 모색했습니다.🎯 풀이방법BFS 문제이며, 시간복잡도는 $O(N M)$ 입니다. arr : 미로가 담긴 리스트. 각 요소에 행에 해당하는 문자열이 들어있다. crack_count : 미로의 각 칸에 대응되는 리스트로, 각 칸에 도달했을 때의 부순 횟수를 저장 풀이방법의 핵심은 crack_count 에 있습니다. BFS 나 DP 에서 일반적으로 사용하는visited 와는 다르게 해당 칸에 도착했을 때 부순 횟수를 저장합니다. 그리고 다음에 그 칸으로 오는 경우저장한 부순 횟수보다 적게 부순 경우에만 큐에 넣어주어 BFS 를 진행합니다. crack_count[N][M] 를 만들어 주고 모든 칸을 (K+1) 로 초기화시켜줍니다. (K+1) 로 초기화시켜주는 이유는 최대 K 번까지 벽을 부술 수 있으므로, 특정 칸에 처음으로 K 번 벽을 부수고 도달했을 때큐에 넣어줄 수 있음을 보장해주기 위해서입니다. (0, 0) 위치에서부터 (N-1, M-1) 위치까지 상하좌우 움직여가며 BFS 를 진행합니다. BFS 를 진행할 때, 다음 칸에 이전에 도착한 경우의 부순 횟수보다 적을 경우에만 탐색을 진행합니다. 다음 칸이 벽일 경우와 빈 칸일 경우, 각 경우에 따라 적절한 행동을 취합니다. 빈 칸일 경우, crack_count 에 현재 부순 횟수를 저장하고, 큐에 현재 상태를 추가합니다. 벽일 경우, (부순 횟수 + 1)이 해당 칸의 crack_count 보다 작을 경우에만 부수고 나아갈 수 있습니다. 현재가 낮이라면 부수고 나아간 후, crack_count 에 반영하고 큐에 추가해줍니다. 현재 상태를 큐에 추가하여 낮이되기를 기다립니다. BFS 를 진행하며 마지막 칸에 도달한 경우에는 BFS 단계를 return 해줍니다. 도달하지 못하고 큐가 비게 된다면, 도달할 수 없으므로 -1 을 return 해줍니다. 🔎 유의할 점 벽을 만나지 않았다면 굳이 제자리에서 낮이 되기를 기다리지 않아도 됩니다. 실질적으로 낮이 필요한건 벽을 부술 때 뿐이니까요.낮이 되길 기다리는건 오히려 탐색량을 늘릴 뿐입니다. 낮밤 여부는 따로 변수로 저장해도 되지만, BFS 단계가 홀수일 때는 낮, 짝수일 때는 밤으로 생각할 수 있습니다. 다음 칸으로 진행하기 전에 현재까지 부순 횟수와 해당 칸의 crack_count 와 비교하여 탐색량을 줄일 수 있습니다.왜냐하면 이전 BFS 단계에서 탐색 순서에 따라 큐에 부순 횟수가 다른 같은 칸을 큐에 넣어줄 수 있습니다.아래 예와 같은 경우 2번을 먼저 수행한 후 1번을 수행하면, 큐에 (1, 3) 칸이 두 번 들어갑니다.하지만 실질적으로 BFS 를 수행해야하는 경우는 1번 경우이므로 코드의 31번 라인과 같이 비교하여 탐색량을 줄일 수 있습니다. 예제 입력 4에서 (0, 0) → (0, 1) → (0, 2) → (0, 3) → (1, 3) 순으로 진행하면 부순 횟수가 1번입니다. (0, 0) → (0, 1) → (0, 2) → (1, 2) → (1, 3) 순으로 진행하면 부순 횟수가 2번입니다. 🧐 알게된 점 2 차원 문제에서 N * M 이 큰 경우, 1차원 리스트로 만들어 푸는 방식은 더 느리다.💻 코드from sys import stdinfrom collections import dequeinput = stdin.readlinedef solve(): N, M, K = map(int, input().split()) if N == 1 and M == 1: return 1 arr = [input()[:-1] for _ in range(N)] d = [(-1, 0), (1, 0), (0, -1), (0, 1)] crack_count = [[K + 1] * M for _ in range(N)] crack_count[0][0] = 0 # (x, y, 벽 부순 횟수) que = deque([(0, 0, 0)]) N_, M_ = N - 1, M - 1 ans = 1 while que: l = len(que) for _ in range(l): ox, oy, crack = que.popleft() if ox == N_ and oy == M_: return ans elif crack == crack_count[ox][oy]: for dx, dy in d: x = ox + dx y = oy + dy if 0 &lt;= x &lt; N and 0 &lt;= y &lt; M: if crack &lt; crack_count[x][y]: # 다음 칸이 빈칸인 경우 # 낮이든 밤이든 상관없다 if arr[x][y] == '0': crack_count[x][y] = crack que.append((x, y, crack)) # 다음 칸이 벽인 경우 else: if crack + 1 &gt;= crack_count[x][y]: continue # 낮인 경우만 벽을 부술 수 있다 elif ans &amp; 1: crack_count[x][y] = crack + 1 que.append((x, y, crack + 1)) # 밤인 경우 제자리에 머무른다 else: que.append((ox, oy, crack)) ans += 1 return -1if __name__ == '__main__': print(solve())" }, { "title": "[백준 1114] 통나무 자르기 (파이썬 / Python)", "url": "/posts/boj-1114/", "categories": "알고리즘, 백준", "tags": "알고리즘, 백준, Greedy, 이분탐색", "date": "2022-04-10 17:53:00 +0900", "snippet": "📑 문제문제링크 : 통나무 자르기🤔 처음 생각맨 처음에 가능한 최대길이의 최솟값은 max_len = ceil(L / (max(C, K) + 1)) 이상이어야 한다고 생각했습니다. 그래서 통나무를 모두 토막낸 후 max_len 길이로 자를 수 있는 위치를 찾아가며 구하려고 했습니다.그런데 자를 수 있는 위치에 따라 max_len 길이의 토막이 없을 수도 있으며, 특정 길이로 자를 수 있는 위치를 전 범위에서 구하기에는 시간 복잡도가 $O(K^2)$ 이며, 줄이기 위해서는 DP까지 써야하는 등 너무 복잡해진다고 생각했습니다.그리고는 이분탐색으로 눈을 돌리게 됐습니다.🎯 풀이방법Greedy, 이분탐색 문제이며, 시간복잡도는 $O(K \\log L)$ 입니다. arr : 시작점과 끝지점을 포함한 자를 수 있는 위치가 담긴 리스트 pieces : 자를 수 있는 모든 지점을 잘랐을 때의 길이들이 역순으로 담긴 리스트 cut(length): 통나무를 length 이하의 길이로 자르는 함수로, 자른 횟수와 처음으로 자르는 위치를 return 해줌 left &amp; right : 잘라야하는 최대 길이를 구하기 위한 이분탐색의 왼쪽과 오른쪽 자를 수 있는 지점들을 입력받아 모두 잘랐을 때 모든 토막의 길이가 어느 정도인지 구합니다. 통나무를 잘랐을 때 각 토막의 길이의 최대값이 최소가 되도록 이분탐색을 진행해야 합니다. left = 0, right = L 부터 시작해서 길이가 통나무 길이를 mid = (left + right) // 2 로 잘랐을 때 몇 번 잘라야하는지 확인합니다. C번 이하로 자를 수 있다면, 길이를 최소 mid 이하로 자를 수 있다는 뜻입니다. 따라서 다음 탐색에서 더 짧은 길이를 탐색하기 위해 right = mid - 1 을 해줍니다. C번 초과로 잘라야한다면, 길이를 최소 mid 보다는 커야한다는 뜻입니다. 따라서 다음 탐색에서 더 긴 길이를 탐색하기 위해 left = mid + 1 을 해줍니다. cut(length) 함수에서는 최대 길이가 length 이하가 되도록 잘라야 하며, 잘라야하는 가장 앞 위치를 반환해야 합니다. pieces 의 원소들을 누적합을 해가며 잘라줍니다. 만약 누적합의 값이 length 이하이면 자르지 않고 다음으로 넘어갑니다. 만약 length보다 커진다면 이전 위치에서 잘라줍니다. pieces 의 원소들을 역순으로 탐색해가며 잘라야합니다. 그래야 절단해야하는 가장 앞 위치를 알아낼 수 있습니다. 모두 잘랐을 때, 자른 횟수가 C번 미만이라면 자를 수 있는 첫 번째 위치를 잘라줄 수 있습니다. 위 과정을 left &lt;= right일 동안 진행하여 답을 구해줍니다. 🔎 유의할 점 자를 수 있는 위치들을 입력받고 정렬해주어야 합니다. 그래야 모두 잘랐을 때의 각 토막의 길이들을 제대로 알 수 있습니다. cut(length) 함수에서 각 토막들을 역순으로 탐색해주어야 합니다. length 이하로 몇 번을 잘라야하는지는 역순으로 탐색하지 않아도 알 수 있지만, 처음으로 절단해야 하는 위치를 알기 위해서는 역순으로 탐색해야만 합니다. C번 미만으로 자른 경우, 자를 수 있는 위치의 맨 앞을 잘라주어야 합니다. 방법이 여러 가지인 경우 처음 자르는 위치가 가장 작아야 하므로, 가능한 절단 위치에서 한 번 더 잘라주어야 합니다. 💻 코드from sys import stdininput = stdin.readlinedef solve(): L, K, C = map(int, input().split()) arr = [0, *sorted([*map(int, input().split())]), L] pieces = [arr[i] - arr[i-1] for i in range(len(arr) - 1, 0, -1)] longest_piece = max(pieces) def cut(length): if longest_piece &gt; length: return 10001, 0 cur_len = 0 count = 0 for piece_len in pieces: cur_len += piece_len if cur_len &gt; length: cur_len = piece_len count += 1 return count, cur_len if count == C else pieces[-1] left, right = 0, L ans_pt, ans_len = 0, 0 while left &lt;= right: mid = (left + right) // 2 cnt, pt = cut(mid) if cnt &lt;= C: ans_pt = pt ans_len = mid right = mid - 1 else: left = mid + 1 return ans_len, ans_ptif __name__ == '__main__': print(*solve())" }, { "title": "[백준 1194] 달이 차오른다, 가자. (파이썬 / Python)", "url": "/posts/boj-1194/", "categories": "알고리즘, 백준", "tags": "알고리즘, 백준, BFS", "date": "2022-04-10 15:43:00 +0900", "snippet": "📑 문제문제링크 : 달이 차오른다, 가자.🎯 풀이방법BFS 문제입니다. arr : 1차원 리스트로 저장된 미로 start : 시작지점 adj(pos) : pos에서 갈 수 있는(벽이 아닌) 다음위치를 반환해주는 제너레이터 visited[i][j] : i번 위치에 열쇠상태 j로(비트마스킹) 방문한적 있는지 여부 출발 지점이 어디인지 파악합니다. 출발 지점으로부터 상하좌우로 벽이 아닌 칸이라면 이동합니다. 이동한 칸이 어떤 칸인지에 따라 해야할 행동이 나뉩니다. 열쇠: 알파벳에 맞게 가지고 있는 키를 비트마스킹 해줍니다. 예를 들어 ‘a’는 0번째이므로 1 « 0, ‘d’는 3번째이므로 1 « 3 으로 비트마스킹 해줍니다. 문: 가지고 있는 열쇠 중 해당 열쇠가 있는지 확인합니다. 만약 가지고 있지 않다면 큐에 해당 칸을 넣어주지 않습니다. 출구: 출구라면 현재 BFS 단계를 return 해줍니다. ‘0’: 출발지점이라면 특별히 해줄 행동은 없습니다. 3번을 수행하고 해당 칸에 존재할 수 있으며, 현재의 key 상태로 해당칸에 방문한 적이 없다면 que에 넣어줍니다. que가 빌 때까지 계속해서 BFS를 진행합니다. 만약 que가 비게 되면 탈출할 수 없으므로 -1을 return 해줍니다. 🔎 유의할 점 단순히 방문한 칸에 대해서만 DP를 하면 안됩니다. 가지고 있는 key에 대해서도 고려하여 각 칸의 방문여부를 체크해야 합니다.💻 코드from sys import stdininput = stdin.readlinedef solve(): N, M = map(int, input().split()) _len = N * M arr = [0] * _len for i in range(N): idx = i * M arr[idx:idx+M] = input()[:-1] start = arr.index('0') def adj(pos): r, c = pos // M, pos % M if 0 &lt; r and arr[pos-M] != '#': yield pos-M if r &lt; N - 1 and arr[pos+M] != '#': yield pos+M if 0 &lt; c and arr[pos-1] != '#': yield pos-1 if c &lt; M - 1 and arr[pos+1] != '#': yield pos+1 visited = [[False] * 64 for _ in range(_len)] # (pos, key) que = [(start, 0)] visited[start][0] = True ans = 1 while que: new_que = [] for pos, org_key in que: for nxt in adj(pos): cell = ord(arr[nxt]) key = org_key # 문인 경우 if 65 &lt;= cell &lt;= 70: # 해당하는 열쇠가 없는 경우 if not key &amp; (1 &lt;&lt; (cell - 65)): continue # 키인 경우 elif 97 &lt;= cell &lt;= 102: key |= 1 &lt;&lt; (cell - 97) # '1'인 경우 elif cell == 49: return ans if not visited[nxt][key]: visited[nxt][key] = True new_que.append((nxt, key)) que = new_que ans += 1 return -1if __name__ == '__main__': print(solve())" }, { "title": "[백준 5214] 환승 (파이썬 / Python)", "url": "/posts/boj-5214/", "categories": "알고리즘, 백준", "tags": "알고리즘, 백준, BFS", "date": "2022-04-09 01:42:00 +0900", "snippet": "📑 문제문제링크 : 환승🎯 풀이방법BFS 문제이며, 시간복잡도는 $O(K M)$ 입니다. arr : 하이퍼튜브 리스트 hyper : 각 역이 존재하는 하이퍼튜브 idx를 담은 리스트 visited : 이미 방문한 역의 번호 que &amp; new_que : BFS를 진행하기 위한 큐 cur : BFS에서 현재 역의 번호 nxt : BFS에서 cur과 같은 하이퍼 튜브에 있으면서 방문한 적 없는 역 ans : 답으로 BFS의 단계 문제의 조건들을 입력받고 초기화 해줍니다. que에 1번 역을 넣고, visited[1] = True로 설정합니다. que에 원소가 있을 동안 계속해서 BFS를 수행합니다. 만약 원소가 없다면 6번으로 갑니다. que에서 원소를 하나씩 꺼내어( = cur ) 현재 역이 N번 역이라면 ans를 return, 아니라면 다음을 수행합니다. cur이 존재하는 하이퍼튜브에 존재하는 cur이 아닌 역들 중, 아직 방문하지 않은 역들( = nxt )을 new_que에 넣어줍니다. visited[nxt] = True를 해줍니다. 이미 이용한 하이퍼튜브들은 다음에 또 사용하면 안되므로, 사용한 하이퍼튜브에는 아무 역이 없도록 초기화시켜줍니다. ans를 하나 늘려주고 que에 new_que를 할당해주며 3번으로 갑니다. N번째 역으로 갈 수 없는 것이므로 -1을 return 해줍니다. 🔎 유의할 점 각 하이퍼 튜브는 한 번씩만 탐색해주어야 합니다. 그래서 제 코드의 37번 라인에서 arr[h] = [ ] 를 해주어, 31번 라인의 for문을 각 하이퍼튜브가 한 번씩만 돌도록 보장해주었습니다.💻 코드from sys import stdininput = stdin.readlinedef solve(): N, K, M = map(int, input().split()) if N == 1: return 1 arr = [[*map(int, input().split())] for _ in range(M)] # hyper[i] = [j] --&gt; j번째 하이퍼튜브에 i번 역이 있다 hyper = [[] for _ in range(N + 1)] for i in range(M): for j in arr[i]: hyper[j].append(i) visited = [False] * (N + 1) visited[1] = True que, ans = [1], 1 # bfs while que: new_que = [] for _ in range(len(que)): cur = que.pop() if cur == N: return ans # cur역이 존재하는 하이퍼 튜브를 돌면서 다음에 갈 수 있는 역을 que에 넣어준다 for h in hyper[cur]: for nxt in arr[h]: if not visited[nxt]: new_que.append(nxt) visited[nxt] = True # 하이퍼 튜브는 한 번만 이용되어야 하므로 비워준다 arr[h] = [] que = new_que ans += 1 return -1if __name__ == '__main__': print(solve())" } ]
